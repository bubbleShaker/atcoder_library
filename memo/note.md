# これは何?
競プロの日記にしようと思う。<br>
思ったことをそのまま打ち込むだけなので、見やすくはならないと思う。<br>

## 10/27 ABC377のバチャ
終わったら、解けなかった問題を一門、すぬけさんの解説見た後にupsolveする。<br>
## 結果
ABCの3完だった。<br>
<img src="../photo/241027/01.png" width="500"><br>
パフォーマンスは816。<br>
Cまではよくある問題という印象。<br>
Dについて解けなかったので考えてみる。<br>

## D-Many Segments 2
<img src="../photo/241027/02.png" width="700"><br>
### 考えた解法
五月雨式に説明する。<br>
#### 配列Aを生成し、$imos法$を行う
配列$A$を作成し、その上で$[li,ri)$について$imos法$を行う。<br>
$A_i>0$なる点$A_i$から数直線上に右に長さ1の区間が塗りつぶされていると考える。<br>
#### 集合$set_L$の定義
塗りつぶした区間の左端となる点$L$を集合$set_L$に挿入する。<br>
#### $1\le l \le M$の点$l$とペアになる点$r$の個数を計算する

##### 1. $A_l=0$の場合
点$l$以上の最小の点$min_L$を二分探索で見つける。<br>
- $l$以上の点が存在しないならば$M-l$個
- そうでないならば$min_L-l$個

の点$r$が点$l$のペアとなりうる。<br>
また、点$l$が$Li=Ri$なる点$p$の集合$set_{p}$に含まれていないならば、$r=l$なる点$r$も点$l$のペアにできる。<br>

##### 2. $A_l>0$の場合
点$l$が
- 集合$set_{ng}$に含まれていない$\land$集合$set_L$に含まれている

ならば、$r=l$なる点$r$を点$l$のペアにできる。<br>

### サンプル3が合わない
上記のアルゴリズムを実装すると、サンプル3の出力が合わない。<br>
サンプル3の入力を数直線上に図示しようとしたらコンテストが終了してしまった。<br>

### 勘違い
- 「$l,r$が$[L_i,R_i]$に含まれるなら駄目」

ではなく、
- 「$l,r$が$[L_i,R_i]$を含むなら駄目」

だった

### すぬけさんの解説を見る
考え直したが、結局難しいので解説を見る。<br>

## 日記感想
アルゴリズムの説明を書かなければならないのが難しく、卒論の時とは異なり理解の補助になっている感じはないと思った。<br>
今後書くかは微妙。<br>

## 11/6
### RMQのSegmentTreeをソラで書けるようにしたい
スニペットを入れないで手打ちでプログラムを作成した方が、脳が活性化されて働く気がする、という経験則を手に入れた。<br>
それと同じような理屈で、主要なアルゴリズムやライブラリは全部ソラで書ける方が、頭が働いていいのでは？と思った。<br>
まずは全緑コーダー憧れのSegmentTreeをいつでもソラで書けるようになりたいと思ったので、2回ほど写経して覚えようとした。<br>
どうにかしてRMQのセグ木だけでも暗記に成功した、という経験が欲しい。<br>

## 11/7 セグ木(RMQ)暗記+ADT
写経1回+テスト2回を紙で。<br>
家に帰ってからテスト1回。<br>
家に帰ったときは、lの配列サイズを間違えてWAが出た。<br>
ADTは2完で悲しくなった。<br>
寝る前に写経を通して暗記して、翌日復習して定着を図るの、かなり効果がある。<br>
今日は風呂に入ったらRSQの暗記をしようと思う。<br>

## 11/8 セグ木(RSQ)テスト+グラフ探索アルゴリズムDFS写経
前日の夜にRSQのセグ木を写経して暗記した。<br>
今日の夜テストしてみたら暗記できていた。<br>
気が向いたらテストしてみて忘れてないか確認することにして、次の暗記するものを探す。<br>
グラフ探索アルゴリズムのdfsを暗記してみる。<br>
参考サイト:[深さ優先探索(Depth First Search)の基本](https://algo-logic.info/dfs/)<br>
stackを使ったdfsプログラムを始めて書いた。面白い。<br>
一つずつテストして、クリア出来たら次に進むことにする。<br>
→写経2回、テスト1回でクリア。<br>
再帰の方も写経しようと思う。<br>
→写経2回、テスト1回でクリア。<br>
では、スタックと再帰をそれぞれテストしてみる。<br>
→スタック…pop()を忘れるミス<br>
→再帰…クリア<br>
という感じになった。<br>
やりすぎると復習が大変なので今日はここで終わろうと思う。それか暇なので適当にセグ木(RMQ,RSQ)が書けるかテストしてみる。<br>
→両方ともクリア。寝る<br>

## 11/9 DFSでの全列挙+諸々テスト
寝起き、2種類のdfsテスト→両方OK<br>
dfsの続きをやったらスマークに散歩がてら行って、ひろきの誕プレでも買おうかと思う。<br>
→写経2回、テスト1回でクリア。<br>
寝る前にとっておいて、日中は別のことをしようと思う。<br>
寝る前になった。スタプラで時間を測るようにしてみたが、あんまり意味があるかは分からず…。<br>
とりあえずDFSでの全列挙を暗記して、そのあとグリッド上でのDFSをテストしてみようと思う。<br>
参考サイト:[再帰関数を用いた深さ優先探索(DFS)による全探索アルゴリズム](https://algo-logic.info/brute-force-dfs/)<br>
→DFSでの全列挙、写経2回、テスト1回でクリア。結構怪しいので、グリッド上のテストの後もう一度やってみる。<br>
→グリッド上のDFS、一か所だけnyをnxとしてしまい1WA。結構時間がかかった…。<br>
この状態でもう一度、DFSの全列挙をテストしてみる。<br>
→クリア。<br>
意外と暗記出来ていてよかった。<br>
セグメントツリーやstackを用いたDFS、全く覚えている気がしなくて怖いが、そう言っていても始まらないのでテストしてみる。<br>
→RMQ,RSQのセグ木、stack,再帰のDFSどちらもテストクリア。<br>
あまり詰め込みすぎてもアレなので、今日はDFSでの全列挙のみで終わりにしようかな、と思う。<br>
### 今後暗記したいアルゴリズム・データ構造
トポロジカルソート、ダイクストラ法、ベルマンフォード法、木の直径、プリム法、クラスカル法、ダブリング、半分全列挙、座標圧縮、Binary Indexed Tree、セグメントツリーなど<br>
緑diff攻略に必要なアルゴリズムを暗記したい。他にもあるかもしれない。<br>
基本的に1日1つ、寝る前に暗記するのが現実的かな、と思う。<br>
個人的な意地だが、これは三日坊主で終わらせたくない。<br>
この暗記を習慣付けて、空で書けるアルゴリズムを増やしていく。<br>

### トポロジカルソートを暗記する
明日朝起きたら面倒なことをしなければならないのが嫌で、つい暗記に走ってしまう。どうせ寝れる気もしないので、トポロジカルソートの暗記をしてみる。<br>
参考サイト:[トポロジカルソートのアルゴリズム（閉路のない有向グラフDAGのソート）](https://algo-logic.info/topological-sort/)<br>
→写経2回、テスト1回でqueueのpushとansのpush_backミス。<br>
次テストしてダメだったら、ノートに書くのも良いかもしれない。<br>
→テストしてクリア。まあまあ怪しいので明日要復習。<br>

### 思ったこと
どうやら順序というものがあるらしく、トポロジカルソートよりも前に、連結成分数の個数の判定などをやった方がよさそう。DFSでのトポロジカルソートを暗記したら、次はそれを暗記する。<br>

## 11/11 ABC379-D 暗記
DFSでの全列挙テスト<br>
→dfsの引数をconstにしてしまいミス<br>
BFSでのトポロジカルソート<br>
→テストクリア<br>
今日は、今日解けなかったD問題を暗記してみる。<br>
→写経2回、テスト1回でクリア。<br>
怪しい、というか怪しさしかないのでDFSでのトポロジカルソートを暗記したらもう一回テストしようかと思ったが、眠いし時間がヤバいので布団の中で復習しようと思う。<br>

## 11/12 ABC379-Dのテスト+DFSでのトポロジカルソート暗記
ABC379-Dのテスト<br>
→while文を書き忘れてミス。<br>
DFSでのトポロジカルソート暗記<br>
→写経一回、テスト一回でクリア。<br>
怪しいのでもう一度テストする。<br>
→テストクリア。明日朝起きてテストする。<br>
時間が余ったので連結成分の個数を求めるプログラムを暗記<br>
→写経一回、テスト一回でクリア。<br>
例によって怪しいので、明日の朝テストする。<br>
最後にもう一度DFSでのトポロジカルソートをテストしておく。<br>

## 11/13 同一連結成分かの判定+単一始点最短経路(ベルマンフォード法)
DFSでのトポロジカルソートテスト<br>
→クリア<br>
同一連結成分に2点が存在するかのプログラムを暗記する。<br>
DFSを用いた愚直な場合について暗記する。<br>
→写経1回、テスト1回でクリア。<br>
次に、効率的に計算する方法について暗記する。<br>
→写経1回、テスト1回でクリア。<br>
Union-Find Treeなるものを使った解法もあるが、それはUnion-Find Treeを暗記してから見てみることにする。<br>
頭がモヤモヤしているので、ベルマンフォード法も暗記する。<br>
→写経2回、テスト1回でクリア。<br>
問題も一つ暗記してみる…？
→[Single Source Shotest Path(Negative Edges)](https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_B&lang=ja)のACコードを暗記することにした。<br>
→作成に1回、テスト1回でクリア。かなり怪しいのでまた明日テストする。<br>
なんか例題に難しそうなのが沢山あるが、まずは完璧に暗記ができてから取り組むことにする。<br>

## 11/14 ADTバチャ+ABC373-D暗記
4完だった。ABC373-Dが解けなかったので暗記したくなってしまった。<br>
写経1回+テスト1回でdfs呼び出し忘れでミス。<br>
これを続けていたら間違いなく日常生活が崩壊するので、忘れることが大切だと思うが…。<br>
つい暗記してしまった。これから忘れようと思う。<br>

## 11/5 dijkstra法暗記
dijkstra法<br>
→写経2回、テスト1回でクリア。<br>
怪しいし解析に関してはよくわかっていないので、また明日テストする。<br>
経路復元と正当性の確認を明日か今日OMCBが終わったら見ようと思う。<br>
OMCBが終わってダイクストラ法テスト1回クリア。経路復元も暗記しようと思う。<br>

## 11/16 
ABC前にダイクストラのテストと経路復元の暗記をする。<br>
→ダイクストラテストクリア。<br>
経路復元を暗記する。<br>
→写経2回、テスト1回でクリア。<br>
例によって怪しいのでまた明日テストする。<br>

### OMCB027-Eの暗記テスト+ABC380-D暗記
OMCB27-Eのテストと、二乗和の公式のテストをする。<br>
→両方ともクリア。<br>
ABC380-Dの解説が難しかったのでとりあえず暗記する。<br>
→プログラム2回写経、テスト1回クリア。<br>
例によってかなり怪しいので明日テストする。<br>
あと、プログラムだけだとかなり難しいと思った。<br>
頭で考えるよりも解説文を暗記したくなった。<br>
→写経2回、テスト2回やったがどっちも駄目。途中で全く思い出せなくなった。<br>
体感これを暗記できるようになるにはあと4回くらいテストしないといけない気がする。3箇所くらい思い出せなさそうな箇所がまだあるので。<br>
この解説文の暗記とプログラムのテストセットで明日はやってみる。<br>
一度に覚えるのは難しそうなので、数日に分けてテストしていきたい。<br>
→各セクションについて写経2回、テスト1回でとりあえずクリア扱い。完全に一致する文章を暗記するのは不可能かもしれない。<br>
アルゴリズムについての暗記はまだしも、解説の暗記はかなり怪しい。だが、これを暗記することができたらかなり良いと思うので、また明日テストする。<br>

## 11/18 dijkstraテスト
ABC380-D 暗記テスト<br>
→テスト1回、クリア。<br>
dijkstraテスト<br>
→テスト1回、for(auto &e:G[v])の&を忘れて1ミス。<br>
経路復元のテストもやる<br>
→テスト1回、また&を忘れた。<br>
外で暗記するのは微妙かもしれないと思った。<br>
ABC380-Eも暗記してみることにした。<br>
→写経2回、テスト1回でクリア。例によって怪しいのでまた明日テストしようと思う。<br>
明日はABC380-Eのテストが終わったら、アルゴリズムロジックの暗記に戻ろうと思う。<br>

## 11/19 ABC380-E+dfsテスト
ABC380-Eのテスト<br>
→クリア。<br>
再帰でのdfsとグリッド上でのdfsテスト<br>
→クリア。<br>
stackでのdfsのテストをしてADTに出ようと思う。<br>
→クリア。ADTをやる。<br>
→初めてMedium全完できた。うれしい。<br>
ベルマンフォード法とダイクストラ法のテスト<br>
→それぞれクリア。<br>
トポロジカルソート(BFS)のテスト<br>
→que.pop()を忘れてミス<br>
トポロジカルソート(DFS)のテスト<br>
→seen.assign(N,false)をしていない、参照渡しをしていないなどの違いがあるが、していることは同じだった。とりあえずそのままにしておく。次にテストするときは参照渡しの方を書くように意識する。<br>
連結成分の個数と同じ連結成分に含まれるかのテスト<br>
→両方ともクリア。<br>
明日は木の直径を求めるプログラムを暗記しようと思う。<br>

## 25/01/11
ABC388に出た。<br>
ABCD(1)4完(perf:876,rating:879→878)。<br>
D問題でfenwick treeを使えば楽に解けると思って使えたのは良かったかな…?と思う。<br>
E問題は決め打ち2分探索だったが、嘘貪欲をずっと考えていて時間切れに。<br>
- 嘘貪欲が駄目なことを確かめる→別の解法を考える

という甘々な考えで嘘貪欲をとりあえず実装したのが敗因だったかな…と思う。<br>
嘘貪欲の実装で55分くらいかかり、ようやく反例のサンプルを見つけたと思ったらコンテストが終了してしまい…。<br>
とは言え、嘘貪欲の実装をせずに反例を見つけた後に、決め打ち二分探索を実装できたかどうかは怪しい。解説を見るまで分からなかったので…。<br>
1. 嘘解法の反例を見つける能力の不足
2. 反例にも対応できる正しいアルゴリズムを考える能力の不足

この2つが敗因だったかなーと思う。<br>
悔しいが、Cまで比較的早く解けて、Dではfenwick treeを使ってなんとかゴリ押せたのは良かったのかな…。と思う。<br>
悔しいので筋トレして寝る。<br>

## 25/01/13
abc385-dをupsolveする。<br>
頭の中で問題を考えて、解法を考えてみたので実装してみる。<br>
→実装するだけだったが、82分かかった…。考察込みだとコンテスト本番で通せない問題だなーという感じ。<br>
バグ取りで30分くらいかかったので、バグを仕込ませない実装をすれば通せるかもしれないが…。<br>
頭が疲れてごちゃごちゃしていてすごい。<br>

## 25/01/18
ABC389に出た。<br>
ABCD4完でパフォは973。自分にしては珍しい900後半のパフォ。<br>
D問題で割と早めに決め打ち二分探索に気付けたのが良かったのかなーと思う。<br>
F問題を考える時間があったのでちょっと考えることが出来て、インラインdp、遅延セグメントツリー上での二分探索、関数群の定義、区間加算などちょっと触れることが出来たのでラッキーだった。<br>
早解き出来るとこういう高度典型を考える時間も自然に生まれるので、いいなーとなった。<br>
チートシートとして、E8さんの中級のQiitaのページと、デバッガの使い方のQiitaを開いておいたけど、お守りって感じだった。<br>
今日は割と悔しさ少な目で寝れそう。パフォ100くらいしか違わないのに…。<br>

## 25/01/25
ABC390に出る。<br>
日中ずっと起きていたし、コンテスト前の仮眠も取れていないので怪しいが…。<br>
一応散歩には行かないで体力を温存したが、小説を一冊読んでしまったので少し疲れてるかも？<br>
カフェインは摂取したが、5分前なのであんまり意味なさそう。<br>
<br>
AB2完(11:00くらい)perf380くらいだった。<br>
Cでめちゃくちゃ詰まってしまって、上手く解けなくてD,Eに行くも駄目だった。<br>
解説でCを見たらめちゃくちゃ分かりやすくて、なんで解けなかったんだ…という気持ちに…<br>
Eは途中まで解いていたが、駄目だった。<br>
……。<br>
今日は割とポジティブに生きていたつもりだったが、結果的に上手くいかなかった。<br>
最初から期待(油断?)をせずに、準備に取り組んでいれば3完くらいは出来たかもしれないので、反省…。<br>

## 25/02/01
少し前からコンテストに出るのは気分に任せることにして、未ACのC~D問題を埋めることを優先することにした。<br>
問題はメモ帳で解法を考えながら解いて、それをsize.meにいくつか投稿している。<br>

## 25/02/06
頭の体操で何問かABC-C埋めをした。<br>
メモに書いてから実装するスタイルを取っているのだが、MD記法の方がインデントを表現出来て整理しやすいかも。そうなるとsizu.meじゃなくてHackMDとかが良いかもしれない。<br>
```
if(hoge)
  if(huga)
    Aをする
  else
    Bをする
else
  Cをする
```
みたいな感じで纏められるので…。<br>
- ABC024 C - 民族大移動
```
S_i<T_iとは限らないことに注意。
1<=i<=d、1<=j<=kについて
各jについて、正の方向に動きたいのか負の方向に動きたいのか整理しておいた方がよさそう。
plus[j]=trueなら正、そうでないなら負の方向に動くとしておく。
now[j]=S_jと初期化する。
if(L_e<=now[j]&&now[j]<=R_e&&now[j]!=T_j)
  if(plus[j])
    if(T_j<=R_i) now[j]=T_j,ans[j]=i
    else now[j]=R_i
  else 
    if(T_j>=L_i) now[j]=T_j,ans[j]=i
    else now[j]=L_i
O(KD)で解ける。
```
これはこれで、具体的にコードにするのか、ある程度日本語に留めておくのか方針がブレそうで微妙…。<br>
メモの良いところは、とりあえず日本語で整理する→コードに落とし込む<br>
という感じで、自分が理解しやすい形で表したものをコードに変換する、という段階的なアプローチが出来ること。なのだが、最初からインデントだとかを気にし始めると、いきなりコードを書いているのとあんまり変わらないアプローチになってしまって、あんまりメモの恩恵がなさそう…という気持ち。<br>
難しいが、とりあえずはsizume用に適当にメモに書き出す方法で引き続きやろうと思う。<br>