{
	"main":{
		"prefix":"main",
		"body":[
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main(){",
			"\t$1",
			"\treturn 0;",
			"}"
		],
		"description":"main関数"
	},
	"ci":{
		"prefix":"ci",
		"body":[
			"${1:int} ${2:n};",
			"cin>>${2:n};"
		],
		"description": "標準入力"
	},
	"ci2":{
		"prefix":"ci2",
		"body":[
			"${1:int} ${2:n},${3:m};",
			"cin>>${2:n}>>${3:m};"
		],
		"description": "2変数の標準入力"
	},
	"ci3":{
		"prefix":"ci3",
		"body":[
			"${1:int} ${2:n},${3:m},${4:k};",
			"cin>>${2:n}>>${3:m}>>${4:k};"
		],
		"description": "3変数の標準入力"
	},
	// "cive":{
	// 	"prefix":"cive",
	// 	"body":[
	// 		"vector<${1:int}> ${2:vec}(${3:n});",
	// 		"for(auto &&in:${2:vec}){",
	// 		"\tcin>>in;",
	// 		"}"
	// 	],
	// 	"description":"vectorの標準入力"
	// },
	// "cive2":{
	// 	"prefix":"cive2",
	// 	"body":[
	// 		"vector<vector<${1:int}>> ${2:vec}(${3:n},vector<${1:int}>(${4:m}));",
	// 		"for(auto &&row:${2:vec}){",
	// 		"\tfor(auto &&in:row){",
	// 		"\t\tcin>>in;",
	// 		"\t}",
	// 		"}"
	// 	],
	// 	"description":"2次元vectorの標準入力"
	// },
	"co":{
		"prefix":"co",
		"body":[
			"cout<<${1:n}<<'\\n';"
		],
		"description": "標準出力"
	},
	"co2":{
		"prefix":"co2",
		"body":[
			"cout<<${1:n}<<' '<<${2:m}<<'\\n';"
		],
		"description": "2変数の標準出力"
	},
	"cove":{
		"prefix":"cove",
		"body":[
			"for(auto out=${1:vec}.begin();out!=${1:vec}.end();out++){",
			"\tcout<<*out<<((out!=--${1:vec}.end())?' ':'\\n');",
			"}"
		],
		"description": "vectorの標準出力"
	},
	"cove2":{
		"prefix":"cove2",
		"body":[
			"for(auto &&row:${1:vec}){",
			"\tfor(auto out=row.begin();out!=row.end();out++){",
			"\t\tcout<<*out<<((out!=--row.end())?' ':'\\n')",
			"\t}",
			"}"
		],
		"description": "2次元vectorの標準出力"
	},
	"coyesno":{
		"prefix":"coyesno",
		"body":[
			"cout<<((${1:condition})?\"Yes\":\"No\")<<'\\n';"
		],
		"description": "YesNoの出力"
	},
	"coaccuracy":{
		"prefix":"coaccuracy",
		"body":[
			"cout<<fixed<<setprecision(10);"
		],
		"description": "setpresicionの指定"
	},
	"cobool":{
		"prefix":"cobool",
		"body":[
			"cout<<boolalpha;"
		],
		"description": "boolalphaの設定。bool値を文字列として出力できる。https://cpprefjp.github.io/reference/ios/boolalpha.html"
	},
	"copad":{
		"prefix":"copad",
		"body":[
			"cout<<setfill('0')<<setw(${1:length})<<${2:out}<<'\\n';"
		],
		"description": "パディングして数値を出力できる。https://cpprefjp.github.io/reference/iomanip/setfill.html"
	},
	"coflush":{
		"prefix":"coflush",
		"body":[
			"cout<<flush;"
		],
		"description": "flushの出力"
	},
	"int":{
		"prefix":"i",
		"body":[
			"int"
		],
		"description": "intの出力"
	},
	"long long":{
		"prefix":"ll",
		"body":[
			"long long"
		],
		"description": "long longの出力"
	},
	"vector":{
		"prefix":"ve",
		"body":[
			"vector<${1:int}>"
		],
		"description": "vector型の出力"
	},
	"vector<vector<int>>":{
		"prefix":"ve2",
		"body":[
			"vector<vector<${1:int}>> ${2:x}(${3:n},vector<${1:int}>(${4:m}));"
		],
		"description": "2次元vector型の出力"
	},
	"set":{
		"prefix":"st",
		"body":[
			"set<${1:int}>"
		],
		"description": "set型の出力"
	},
	"unordered_set":{
		"prefix":"ust",
		"body":[
			"unordered_set<${1:int}>"
		],
		"description": "unordered_set型の出力"
	},
	"multiset":{
		"prefix":"mst",
		"body":[
			"multiset<${1:int}>"
		],
		"description": "multiset型の出力"
	},
	"map":{
		"prefix":"mp",
		"body":[
			"map<${1:int},${2:int}>"
		],
		"description": "map型の出力"
	},
	"unordered_map":{
		"prefix":"ump",
		"body":[
			"unordered_map<${1:int},${2:int}>"
		],
		"description": "unordered_map型の出力"
	},
	"stack":{
		"prefix":"stk",
		"body":[
			"stack<${1:int}>"
		],
		"description": "stack型の出力"
	},
	"queue":{
		"prefix":"que",
		"body":[
			"queue<${1:int}>"
		],
		"description": "queue型の出力"
	},
	"priority_queue":{
		"prefix":"pq",
		"body":[
			"priority_queue<${1:int}>"
		],
		"description": "priority_queue型の出力"
	},
	"heap_queue":{
		"prefix":"hq",
		"body":[
			"priority_queue<${1:int},vector<${1:int}>,greater<${1:int}>>"
		],
		"description": "heap_queue型の出力"
	},
	"vecsized":{
		"prefix":"vecsized",
		"body":[
			"vector<${1:int}> ${2:a}(${3:n});"
		],
		"description": "vector型のサイズ付き出力"
	},
	"vec2sized":{
		"prefix":"vecsized2",
		"body":[
			"vector<vector<${1:int}>> ${2:a}(${3:n},vector<${1:int}>(${4:m}));"
		],
		"description": "2次元vector型のサイズ付き出力"
	},
	"INFi":{
		"prefix":"infi",
		"body":[
			"const int INF=1e9;"
		],
		"description": "INFiの出力"
	},
	"INFll":{
		"prefix":"infll",
		"body":[
			"const long long INF=1e18;"
		],
		"description": "INFllの出力"
	},
	"dxdy":{
		"prefix":"dxdy",
		"body":[
			"const vector<int> dx={-1,0,1,0};",
			"const vector<int> dy={0,1,0,-1};"
		],
		"description": "dxdyの出力"
	},
	"dxdy8":{
		"prefix":"dxdy8",
		"body":[
			"const vector<int> dx={-1,-1,0,1,1,1,0,-1};",
			"const vector<int> dy={0,1,1,1,0,-1,-1,-1};"
		],
		"description": "dxdy8の出力"
	},
	"for0":{
		"prefix":"for0",
		"body":[
			"for(${1:int} ${2:i}=0;${2:i}<${3:n};${2:i}++){",
			"\t$4",
			"}"
		],
		"description": "for文"
	},
	"forr":{
		"prefix":"forr",
		"body":[
			"for(${1:int} ${2:i}=${3:n}-1;${2:i}>=0;${2:i}--){",
			"\t$4",
			"}"
		],
		"description": "逆向きfor文"
	},
	"forrange":{
		"prefix":"forrange",
		"body":[
			"for(auto &&${1:num}:${2:vec}){",
			"\t$3",
			"}"
		],
		"description": "forrange"
	},
	"lf":{
		"prefix":"lf",
		"body":[
			"'\\n'"
		],
		"description": "改行文字"
	},
	"lforspace":{
		"prefix":"lforspace",
		"body":[
			"((${1:condition})?' ':'\\n')"
		],
		"description": "空白or改行文字"
	},
	"all":{
		"prefix":"all",
		"body":[
			"${1:vec}.begin(),${1:vec}.end()"
		],
		"description": "イテレータ全範囲"
	},
	"chmax":{
		"prefix":"chmax",
		"body":[
			"${1:max}=max(${1:max},${2:target});"
		],
		"description": "chmax"
	},
	"chmin":{
		"prefix":"chmin",
		"body":[
			"${1:min}=min(${1:min},${2:target});"
		],
		"description": "chmin"
	},
	"popcount":{
		"prefix":"popcount",
		"body":[
			"__builtin_popcount(${1:value})"
		],
		"description": "popcount"
	},
	"popcountll":{
		"prefix":"popcountll",
		"body":[
			"__builtin_popcountll(${1:value})"
		],
		"description": "popcountll"
	},
	"lamda":{
		"prefix":"lamda",
		"body":[
			"[&]($1){$2};"
		],
		"description": "lamdaname"
	},
	"lamdaname":{
		"prefix":"lamdaname",
		"body":[
			"auto ${1:name}=[&]($2){",
			"\t$3",
			"};"
		],
		"description": "lamdaname"
	},
	"binarysearch":{
		"prefix":"binarysearch",
		"body":[
			"auto isOk=[&](${1:type} mid){",
			"\t",
			"};",
			"${1:type} ok=${2:okbound};",
			"${1:type} ng=${3:ngbound};",
			"while(abs(ok-ng)>1){",
			"\t${1:type} mid=(ok+ng)/2;",
			"\tif(isOk(mid)){",
			"\t\tok=mid;",
			"\t}else{",
			"\t\tng=mid;",
			"\t}",
			"}"
		],
		"description": "binarysearch"
	},
	"acl":{
		"prefix":"acl",
		"body":[
			"#include <atcoder/${1|fenwicktree,segtree,lazysegtree,string,math,convolution,modint,dsu,maxflow,mincostflow,scc,twosat|}>",
			"using namespace atcoder;"
		],
		"description": "acl"
	},
	"mint":{
		"prefix":"mint",
		"body":[
			"using mint=modint${1|998244353,1000000007|};"
		],
		"description": "mint"
	},
	"SegTreeRMQ":{
		"prefix":"segtreeRMQ",
		"body":[
			"template<typename T>",
			"class SegTree{",
			"\tprivate:",
			"\t//配列の要素数",
			"\tint n;",
			"\t//木のノード",
			"\tvector<T> node;",
			"\t//ノード1の要素数",
			"\tint siz;",
			"\tconst T INF=1e9;",
			"\tvoid init(){",
			"\t\t//sizをn以上の最小の2冪数にする",
			"\t\tsiz=1;",
			"\t\t//nodeのサイズ",
			"\t\tint m=1;",
			"\t\twhile(siz<n){",
			"\t\t\tsiz*=2;",
			"\t\t\tm+=siz;",
			"\t\t}",
			"\t\t//nodeの数を初期化",
			"\t\tnode.resize(m);",
			"\t}",
			"\tpublic:",
			"\tSegTree(int num):n(num){",
			"\t\tinit();",
			"\t}",
			"\t//a[pos]をxに更新",
			"\tvoid update(int pos,T x){",
			"\t\tpos=pos+siz-1;",
			"\t\tnode[pos]=x;",
			"\t\twhile(pos>=2){",
			"\t\t\tpos/=2;",
			"\t\t\tnode[pos]=max(node[pos*2],node[pos*2+1]);",
			"\t\t}",
			"\t}",
			"\t//半開区間[l,r)の最大値を求める",
			"\t//u:現在のセル番号、[a,b):セルに対応する半開区間、[l,r):求めたい半開区間",
			"\t//半開区間[l,r)の最大値を求めるにはquery(l,r,1,siz+1,1)を呼び出せばよい",
			"\tT query(int l,int r,int a,int b,int u){",
			"\t\t//一切含まれない場合",
			"\t\tif(r<=a||b<=l){",
			"\t\t\treturn -INF;",
			"\t\t}",
			"\t\t//完全に含まれる場合",
			"\t\tif(l<=a&&b<=r){",
			"\t\t\treturn node[u];",
			"\t\t}",
			"\t\tint m=(a+b)/2;",
			"\t\tT leftAns=query(l,r,a,m,u*2);",
			"\t\tT rightAns=query(l,r,m,b,u*2+1);",
			"\t\treturn max(leftAns,rightAns);",
			"\t}",
			"\tT calcQuery(int l,int r){",
			"\t\treturn query(l,r,1,siz+1,1);",
			"\t}",
			"\tint getSiz(){",
			"\t\treturn siz;",
			"\t}",
			"};",
		],
		"description": "segtreeRMQ"
	},
	"SegTreeRSQ":{
		"prefix":"segtreeRSQ",
		"body":[
			"template<typename T>",
			"class SegTree{",
			"\tprivate:",
			"\t//配列の要素数",
			"\tint n;",
			"\t//木のノード",
			"\tvector<T> node;",
			"\t//ノード1の要素数",
			"\tint siz;",
			"\tconst T INF=1e9;",
			"\tvoid init(){",
			"\t\t//sizをn以上の最小の2冪数にする",
			"\t\tsiz=1;",
			"\t\t//nodeのサイズ",
			"\t\tint m=1;",
			"\t\twhile(siz<n){",
			"\t\t\tsiz*=2;",
			"\t\t\tm+=siz;",
			"\t\t}",
			"\t\t//nodeの数を初期化",
			"\t\tnode.resize(m);",
			"\t}",
			"\tpublic:",
			"\tSegTree(int num):n(num){",
			"\t\tinit();",
			"\t}",
			"\t//a[pos]をxに更新",
			"\tvoid update(int pos,T x){",
			"\t\tpos=pos+siz-1;",
			"\t\tnode[pos]=x;",
			"\t\twhile(pos>=2){",
			"\t\t\tpos/=2;",
			"\t\t\tnode[pos]=node[pos]=node[pos*2]+node[pos*2+1];",
			"\t\t}",
			"\t}",
			"\t//半開区間[l,r)の最大値を求める",
			"\t//u:現在のセル番号、[a,b):セルに対応する半開区間、[l,r):求めたい半開区間",
			"\t//半開区間[l,r)の最大値を求めるにはquery(l,r,1,siz+1,1)を呼び出せばよい",
			"\tT query(int l,int r,int a,int b,int u){",
			"\t\t//一切含まれない場合",
			"\t\tif(r<=a||b<=l){",
			"\t\t\treturn 0;",
			"\t\t}",
			"\t\t//完全に含まれる場合",
			"\t\tif(l<=a&&b<=r){",
			"\t\t\treturn node[u];",
			"\t\t}",
			"\t\tint m=(a+b)/2;",
			"\t\tT leftAns=query(l,r,a,m,u*2);",
			"\t\tT rightAns=query(l,r,m,b,u*2+1);",
			"\t\treturn leftAns+rightAns;",
			"\t}",
			"\tT calcQuery(int l,int r){",
			"\t\treturn query(l,r,1,siz+1,1);",
			"\t}",
			"\tint getSiz(){",
			"\t\treturn siz;",
			"\t}",
			"};",
		],
		"description": "segtreeRSQ"
	},
	"Doubling":{
		"prefix":"doubling",
		"body":[
			"template<typename T>",
			"class Doubling{",
			"private:",
			"\tvector<T> a;",
			"\tvector<vector<T>> dp;",
			"\tvoid init(){",
			"\t\tint n=a.size();",
			"\t\t//今回は日数の最大値が10^9なので、2^29程度まで計算すればよい",
			"\t\t//日数の最大値が10^18とかなら、2^59程度まで計算することになりそう…?",
			"\t\tdp.resize(30,vector<T>(n+1));",
			"\t\t//初期値の代入",
			"\t\t//穴iにいた2^0日後の場所:dp[0][i]",
			"\t\t//穴iにいた2^1日後の場所:dp[1][i]",
			"\t\t//穴iにいた2^2日後の場所:dp[2][i]",
			"\t\t//穴iにいた2^3日後の場所:dp[3][i]",
			"\t\tfor(int i=1;i<=n;i++){",
			"\t\t\tdp[0][i]=a[i-1];",
			"\t\t}",
			"\t\t//前計算",
			"\t\t//1日後の1日後は2日後",
			"\t\t//dp[1][i]=dp[0][dp[0][i]]",
			"\t\t//2日後の2日後は4日後",
			"\t\t//dp[2][i]=dp[1][dp[1][i]]",
			"\t\t//4日後の4日後は8日後",
			"\t\t//dp[3][i]=dp[2][dp[2][i]]",
			"\t\tfor(int i=1;i<=29;i++){",
			"\t\t\tfor(int j=1;j<=n;j++){",
			"\t\t\t\tdp[i][j]=dp[i-1][dp[i-1][j]];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"public:",
			"\tDoubling(vector<T> v):a(v){",
			"\t\tinit();",
			"\t}",
			"\t//場所xにいる時、y日後にいる場所を求める",
			"\tT calcPos(T x,T y){",
			"\t\tT curPos=x;",
			"\t\t//例:穴2にいた13日後の場所",
			"\t\t//13=2^3+2^2+2^0",
			"\t\t//穴2にいた8日後の場所はdp[3][2]=3",
			"\t\t//穴3にいた4日後の場所はdp[2][3]=7",
			"\t\t//穴7にいた1日後の場所はdp[0][7]=3",
			"\t\tfor(int d=29;d>=0;d--){",
			"\t\t\tif(y&(1<<d)){",
			"\t\t\t\tcurPos=dp[d][curPos];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn curPos;",
			"\t}",
			"};",
		],
		"description": "Doubling"
	},
	"StringHash":{
		"prefix":"stringhash",
		"body":[
			"#include <atcoder/modint>",
			"using namespace atcoder;",
			"using mint=modint998244353;",
			"class StringHash{",
			"private:",
			"\tstring s;",
			"\t//基数100でハッシュ値計算しているのでオーバーフロー対策でmintを使う",
			"\tvector<mint> t,H,B;",
			"\tvoid init(){",
			"\t\t//文字列sを数列tに変換",
			"\t\tint n=s.size();",
			"\t\tt.resize(n+1);",
			"\t\tfor(int i=0;i<n;i++){",
			"\t\t\tt[i]=s[i]-'a'+1;",
			"\t\t}",
			"\t\t//ハッシュ値の前計算のコンポーネント",
			"\t\tH.resize(n+1);",
			"\t\tfor(int i=1;i<=n;i++){",
			"\t\t\tH[i]=100*H[i-1]+t[i-1];",
			"\t\t}",
			"\t\t//ハッシュ値の前計算のコンポーネント2",
			"\t\tB.resize(n+1);",
			"\t\tB[0]=1;",
			"\t\tfor(int i=1;i<=n;i++){",
			"\t\t\tB[i]=B[i-1]*100;",
			"\t\t}",
			"\t}",
			"public:",
			"\tStringHash(string str):s(str){",
			"\t\tinit();",
			"\t}",
			"\t//s[l,r]のハッシュ値の計算",
			"\tmint hash(int l,int r){",
			"\t\treturn H[r]-B[r-l+1]*H[l-1];",
			"\t}",
			"};",
		],
		"description": "StringHash"
	},
  "cigraph":{
		"prefix":"cigraph",
		"body":[
			"int n,m;",
      "cin>>n>>m;",
      "vector<vector<int>> g(n+1);",
      "for(int i=0;i<m;i++){",
      "\tint a,b;",
      "\tcin>>a>>b;",
      "\tg[a].push_back(b);",
      "\tg[b].push_back(a);",
      "}",
		],
		"description": "n頂点m辺の隣接リストの入力"
	},
  "dfs":{
		"prefix":"lamdadfs",
		"body":[
      "auto dfs=[&](auto dfs,)->${1:type}{",
      "\t",
      "};",
		],
		"description": "lamdadfs"
	},
  "reverse":{
		"prefix":"reverse",
		"body":[
      "reverse(${1:vec}.begin(),${1:vec}.end());",
		],
		"description": "reverse"
	},
  "bfs":{
		"prefix":"bfs",
		"body":[
      "const int INF=1e9;",
      "vector<int> dist(n+1,INF);",
      "auto bfs=[&](){",
      "\tqueue<int> que;",
      "\tque.push(1);",
      "\tdist[1]=0;",
      "\twhile(!que.empty()){",
      "\t\tint u=que.front();",
      "\t\tque.pop();",
      "\t\tfor(auto v:g[u]){",
      "\t\t\tif(dist[v]!=INF){",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      "\t\t\tdist[v]=dist[u]+1;",
      "\t\t\tque.push(v);",
      "\t\t}",
      "\t}",
      "};",
      "bfs();",
		],
		"description": "隣接リストに対して頂点1から各頂点への最短距離を記録するbfs"
	},
  "dijkstra":{
		"prefix":"dijkstra",
		"body":[
      "const long long INF=1e18;",
			"auto dijkstra=[&](int start){",
			"\tvector<long long> cur(n+1,INF);//暫定距離を記録",
			"\tvector<bool> confirmed(n+1);//最短距離が確定した頂点",
			"\tpriority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> hque;",
			"\thque.push({0,start});",
			"\tcur[start]=0;",
			"\twhile(!hque.empty()){",
			"\t\tauto [_,u]=hque.top();",
			"\t\thque.pop();",
			"\t\tif(confirmed[u]){// !確定済み頂点である間、キューの最小値を削除し続ける",
			"\t\t\tcontinue;// !これを入れないとO(M^2)になってしまうケースがありそう。",
			"\t\t\t// !実際に実験すると、下の*での確認だけでは、同じ頂点に対して複数の{コスト,頂点}の要素が入りうると分かる。",
			"\t\t\t// !これを入れないと同じ頂点に対してN回ループ処理することになり、ボトルネックになりうる。",
			"\t\t\t// !実験メモ",
			"\t\t\t// !完全グラフに対して、キューへのpushの時にコストが全部同じになるようにしてシミュレーション。",
			"\t\t\t// !キューの要素は合計で2M個になった。",
			"\t\t\t// !これらの要素全てについてN回調べると、2M+(2M-N)N回の計算をするため、O(NM)となる。",
			"\t\t\t// !この!での確認を行えば2M+log(MlogM)でconfirmを全て確定できる。",
			"\t\t\t// !よって全体でO(MlogM)になりそう。",
			"\t\t}",
			"\t\tconfirmed[u]=true;",
			"\t\tfor(auto [c,v]:g[u]){",
			"\t\t\tif(!confirmed[v]){//隣接している未確定頂点についてcurを更新",
			"\t\t\t\t// *正直こっちの確認は計算量削減にはあまり寄与しない",
			"\t\t\t\t//各頂点の次数の総和は2Mなので、2M回しかキューには入らなく、!で示した部分があればそれぞれO(1)しか影響しない。",
			"\t\t\t\tcur[v]=min(cur[v],c+cur[u]);//!暫定距離を更新していく",
			"\t\t\t\t//!暫定距離の更新は現在の値とのchminを取りつつ更新することに注意",
			"\t\t\t\t//!push時にcur更新、pop時にconfirm確定、という気持ちでよさそう",
			"\t\t\t\t//!curは更新されるとは限らないことに注意",
			"\t\t\t\thque.push({cur[v],v});//ヒープキューに暫定距離を入れつつ",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn cur;",
			"};",
			"vector<long long> cur=dijkstra(1);",
		],
		"description": "コスト保持した隣接リストに対して、頂点1からダイクストラ法"
	},
  "ciwgraph":{
		"prefix":"ciwgraph",
		"body":[
      "int n,m;",
      "cin>>n>>m;",
      "vector<vector<pair<int,int>>> g(n+1);",
      "for(int i=0;i<m;i++){",
      "\tint a,b,c;",
      "\tcin>>a>>b>>c;",
      "\tg[a].push_back({c,b});",
      "\tg[b].push_back({c,a});",
      "}",
		],
		"description": "コスト付きn頂点m辺の隣接リスト入力"
	},
	"rall":{
		"prefix":"rall",
		"body":[
			"${1:vec}.rbegin(),${1:vec}.rend()"
		],
		"description": "逆からイテレータ全範囲"
	},
	"sort":{
		"prefix":"sort",
		"body":[
			"sort(${1:vec}.begin(),${1:vec}.end());"
		],
		"description": "昇順ソート"
	},
	"rsort":{
		"prefix":"rsort",
		"body":[
			"sort(${1:vec}.rbegin(),${1:vec}.rend());"
		],
		"description": "降順ソート"
	},
	"cerr":{
		"prefix":"ce",
		"body":[
			"cerr<<${1:num}<<'\\n';"
		],
		"description": "cerr"
	},
	"cerr2":{
		"prefix":"ce2",
		"body":[
			"cerr<<${1:num}<<${2:num}<<'\\n';"
		],
		"description": "cerr2"
	},
	"ci4":{
		"prefix":"ci4",
		"body":[
			"${1:int} ${2:n},${3:m},${4:k},${5:l};",
			"cin>>${2:n}>>${3:m}>>${4:k}>>${5:l};"
		],
		"description": "4変数の標準入力"
	},
	"lamdafloori":{
		"prefix":"lamdafloori",
		"body":[
			"auto floori=[&](int a,int b){",
			"\treturn a/b;",
			"};",
		],
		"description": "lamdafloori"
	},
	"lamdaceili":{
		"prefix":"lamdaceili",
		"body":[
			"auto ceili=[&](int a,int b){",
			"\treturn (a+(b-1))/b;",
			"};",
		],
		"description": "lamdaceili"
	},
	"lamdafloorll":{
		"prefix":"lamdafloorll",
		"body":[
			"auto floorll=[&](long long a,long long b){",
			"\treturn a/b;",
			"};",
		],
		"description": "lamdafloorll"
	},
	"lamdaceilll":{
		"prefix":"lamdaceilll",
		"body":[
			"auto ceilll=[&](long long a,long long b){",
			"\treturn (a+(b-1))/b;",
			"};",
		],
		"description": "lamdaceilll"
	},
	"sankou":{
		"prefix":"sankou",
		"body":[
			"((${1:condition})?${2:a}:${3:b})",
		],
		"description": "sankou"
	},
	"pair":{
		"prefix":"pair",
		"body":[
			"pair<${1:int},${1:int}>",
		],
		"description": "pair"
	},
	"veclear":{
		"prefix":"veclear",
		"body":[
			"${1:vec}.clear();",
			"${1:vec}.resize(${2:size},${3:val});",
		],
		"description": "veclear"
	},
	"for1":{
		"prefix":"for1",
		"body":[
			"for(${1:int} ${2:i}=1;${2:i}<=${3:n};${2:i}++){",
			"\t$4",
			"}"
		],
		"description": "1indexed-for文"
	},
	"push_back":{
		"prefix":"push_back",
		"body":[
			"push_back($1);",
		],
		"description": "push_back"
	},
	"treediameter":{
		"prefix":"treediameter",
		"body":[
			"// !gはコスト付き木であるとする",
			"const long long INF=1e18;",
			"auto dijkstra=[&](int start){",
			"\tvector<long long> cur(n+1,-INF);//暫定距離を記録",
			"\tvector<bool> confirmed(n+1);//最短距離が確定した頂点",
			"\tpriority_queue<pair<long long,int>> pque;",
			"\tpque.push({0,start});",
			"\tcur[start]=0;",
			"\twhile(!pque.empty()){",
			"\t\tauto [_,u]=pque.top();",
			"\t\tpque.pop();",
			"\t\tif(confirmed[u]){// !確定済み頂点である間、キューの最小値を削除し続ける",
			"\t\t\tcontinue;// !これを入れないとO(M^2)になってしまうケースがありそう。",
			"\t\t\t// !実際に実験すると、下の*での確認だけでは、同じ頂点に対して複数の{コスト,頂点}の要素が入りうると分かる。",
			"\t\t\t// !これを入れないと同じ頂点に対してN回ループ処理することになり、ボトルネックになりうる。",
			"\t\t\t// !実験メモ",
			"\t\t\t// !完全グラフに対して、キューへのpushの時にコストが全部同じになるようにしてシミュレーション。",
			"\t\t\t// !キューの要素は合計で2M個になった。",
			"\t\t\t// !これらの要素全てについてN回調べると、2M+(2M-N)N回の計算をするため、O(NM)となる。",
			"\t\t\t// !この!での確認を行えば2M+log(MlogM)でconfirmを全て確定できる。",
			"\t\t\t// !よって全体でO(MlogM)になりそう。",
			"\t\t}",
			"\t\tconfirmed[u]=true;",
			"\t\tfor(auto [c,v]:g[u]){",
			"\t\t\tif(!confirmed[v]){//隣接している未確定頂点についてcurを更新",
			"\t\t\t\t// *正直こっちの確認は計算量削減にはあまり寄与しない",
			"\t\t\t\t//各頂点の次数の総和は2Mなので、2M回しかキューには入らなく、!で示した部分があればそれぞれO(1)しか影響しない。",
			"\t\t\t\tcur[v]=max(cur[v],c+cur[u]);//!暫定距離を更新していく",
			"\t\t\t\t//!暫定距離の更新は現在の値とのchminを取りつつ更新することに注意",
			"\t\t\t\t//!push時にcur更新、pop時にconfirm確定、という気持ちでよさそう",
			"\t\t\t\t//!curは更新されるとは限らないことに注意",
			"\t\t\t\tpque.push({cur[v],v});//ヒープキューに暫定距離を入れつつ",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn cur;",
			"};",
			"int s,t; //s,tは直径の両端のノード。",
			"vector<long long> ds=dijkstra(1); //適当な頂点からダイクストラをして、そこからの最大コストを持つ頂点sを決める。",
			"// *木のある頂点からの最大距離を持つ頂点は、直径のノードのどちらかになるので、sは直径のノードの片方となる",
			"long long cost=-1; //costが最大のノードを探すので、costは取り得ない数にしておく。",
			"for(int i=1;i<=n;i++){",
			"\tif(i==1){ //自分自身は遷移として考えない(問題によって頂点倍加でコストを追加すると、これがないと自分に遷移する可能性がある)",
			"\t\tcontinue;",
			"\t}",
			"\tif(cost<ds[i]){ //ds[i]は1からiへの到達コスト",
			"\t\t//ds[i]がcostよりも大きいなら、最大のcostと暫定頂点sを更新する。",
			"\t\tcost=ds[i];",
			"\t\ts=i;",
			"\t}",
			"}",
			"vector<long long> dt=dijkstra(s); //直径のノードの片方であるsからダイクストラをして、もう片方の直径のノードtを求める",
			"// 最大距離を持つノードがtとなる。",
			"cost=-1; //costの初期化",
			"for(int i=1;i<=n;i++){",
			"\tif(i==s){ //1からダイクストラをした時と同様に、自分自身を遷移に含まないようにする。",
			"\t\tcontinue;",
			"\t}",
			"\tif(cost<dt[i]){ //1からダイクストラをした時と同様に、costと暫定頂点tを更新していく。",
			"\t\tcost=dt[i];",
			"\t\tt=i;",
			"\t}",
			"}",
		],
		"description": "コスト付き木の直径をダイクストラを用いて求める。s,tが直径のノード。1-indexedを前提としている。"
	},
	"treeDiameterAndCalcCost":{
		"prefix":"treeDiameterAndCalcCost",
		"body":[
			"// !gはコスト付き木であるとする",
			"const long long INF=1e18;",
			"auto dijkstra=[&](int start){",
			"\tvector<long long> cur(n+1,-INF);//暫定距離を記録",
			"\tvector<bool> confirmed(n+1);//最短距離が確定した頂点",
			"\tpriority_queue<pair<long long,int>> pque;",
			"\tpque.push({0,start});",
			"\tcur[start]=0;",
			"\twhile(!pque.empty()){",
			"\t\tauto [_,u]=pque.top();",
			"\t\tpque.pop();",
			"\t\tif(confirmed[u]){// !確定済み頂点である間、キューの最小値を削除し続ける",
			"\t\t\tcontinue;// !これを入れないとO(M^2)になってしまうケースがありそう。",
			"\t\t\t// !実際に実験すると、下の*での確認だけでは、同じ頂点に対して複数の{コスト,頂点}の要素が入りうると分かる。",
			"\t\t\t// !これを入れないと同じ頂点に対してN回ループ処理することになり、ボトルネックになりうる。",
			"\t\t\t// !実験メモ",
			"\t\t\t// !完全グラフに対して、キューへのpushの時にコストが全部同じになるようにしてシミュレーション。",
			"\t\t\t// !キューの要素は合計で2M個になった。",
			"\t\t\t// !これらの要素全てについてN回調べると、2M+(2M-N)N回の計算をするため、O(NM)となる。",
			"\t\t\t// !この!での確認を行えば2M+log(MlogM)でconfirmを全て確定できる。",
			"\t\t\t// !よって全体でO(MlogM)になりそう。",
			"\t\t}",
			"\t\tconfirmed[u]=true;",
			"\t\tfor(auto [c,v]:g[u]){",
			"\t\t\tif(!confirmed[v]){//隣接している未確定頂点についてcurを更新",
			"\t\t\t\t// *正直こっちの確認は計算量削減にはあまり寄与しない",
			"\t\t\t\t//各頂点の次数の総和は2Mなので、2M回しかキューには入らなく、!で示した部分があればそれぞれO(1)しか影響しない。",
			"\t\t\t\tcur[v]=max(cur[v],c+cur[u]);//!暫定距離を更新していく",
			"\t\t\t\t//!暫定距離の更新は現在の値とのchminを取りつつ更新することに注意",
			"\t\t\t\t//!push時にcur更新、pop時にconfirm確定、という気持ちでよさそう",
			"\t\t\t\t//!curは更新されるとは限らないことに注意",
			"\t\t\t\tpque.push({cur[v],v});//ヒープキューに暫定距離を入れつつ",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn cur;",
			"};",
			"int s,t; //s,tは直径の両端のノード。",
			"vector<long long> ds=dijkstra(1); //適当な頂点からダイクストラをして、そこからの最大コストを持つ頂点sを決める。",
			"// *木のある頂点からの最大距離を持つ頂点は、直径のノードのどちらかになるので、sは直径のノードの片方となる",
			"long long cost=-1; //costが最大のノードを探すので、costは取り得ない数にしておく。",
			"for(int i=1;i<=n;i++){",
			"\tif(i==1){ //自分自身は遷移として考えない(問題によって頂点倍加でコストを追加すると、これがないと自分に遷移する可能性がある)",
			"\t\tcontinue;",
			"\t}",
			"\tif(cost<ds[i]){ //ds[i]は1からiへの到達コスト",
			"\t\t//ds[i]がcostよりも大きいなら、最大のcostと暫定頂点sを更新する。",
			"\t\tcost=ds[i];",
			"\t\ts=i;",
			"\t}",
			"}",
			"vector<long long> dt=dijkstra(s); //直径のノードの片方であるsからダイクストラをして、もう片方の直径のノードtを求める",
			"// 最大距離を持つノードがtとなる。",
			"cost=-1; //costの初期化",
			"for(int i=1;i<=n;i++){",
			"\tif(i==s){ //1からダイクストラをした時と同様に、自分自身を遷移に含まないようにする。",
			"\t\tcontinue;",
			"\t}",
			"\tif(cost<dt[i]){ //1からダイクストラをした時と同様に、costと暫定頂点tを更新していく。",
			"\t\tcost=dt[i];",
			"\t\tt=i;",
			"\t}",
			"}",
			"// 直径のノードs,tからダイクストラをする。",
			"// 直径の性質より、cur1[u]またはcur2[u]がuに対して最大コストを持つ頂点へのコストとなる。",
			"vector<long long> cur1=dijkstra(s);",
			"vector<long long> cur2=dijkstra(t);",
			"for(int i=1;i<=n;i++){ //各頂点iについて最大コストを持つ頂点へのコストを調べる。",
			"\tlong long ans=-1; //最大値を調べるので、ansは-1としておく。",
			"\tif(i!=s){ //iからsへのコストを調べる時、iがsである時は考えない(頂点倍加などでコストに何か追加される場合、かつ自分への遷移は認めない時、これがないと自身へ遷移しうる)",
			"\t\tans=max(ans,cur1[i]);",
			"\t}",
			"\tif(i!=t){ //iからtへのコストを調べる時、sの時と同様に、iがtの時は考えない。",
			"\t\tans=max(ans,cur2[i]);",
			"\t\t",
			"\t}",
			"\tcout<<ans<<'\n'; //iに対して最大コストを持つ頂点(s,tのいずれか)へのコストを出力",
			"}",
		],
		"description": "コスト付き木の直径をダイクストラを用いて求める+直径の性質を用いて各頂点が持つ最大コストを持つ頂点に対するコストを計算する"
	},
	"return":{
		"prefix":"re0",
		"body":[
			"return 0;",
		],
		"description": "return 0を返す"
	},
	"coyes":{
		"prefix":"coye",
		"body":[
			"cout<<\"Yes\"<<'\\n';",
		],
		"description": "coye"
	},
	"cono":{
		"prefix":"cono",
		"body":[
			"cout<<\"No\"<<'\\n';",
		],
		"description": "cono"
	},
	"bitset":{
		"prefix":"bs",
		"body":[
			"bitset<${1:size}> ${2:bs}(${3:n});",
			"//リファレンス:https://cpprefjp.github.io/reference/bitset/bitset.html",
			"//雑メモ:coutで2進法表記で出力",
			"//整数から10ビットのビット集合を構築",
			"//bitset<10> bs(5)",
			"//論理和、論理積、排他的論理和もサポートしている",
			"//他にも[]で任意のビットにアクセス、countで1になっているビットの数を取得など",
			"//様々なメソッド、アクセッサー?、演算子などが定義されている",
		],
		"description": "bitset"
	},
	"stoi":{
		"prefix":"stoi",
		"body":[
			"stoi(${1:str},0,${2:base});",
			"//str…変換したい文字列",
			"//base...変換する文字列の基数(2進数を変換したいなら2とする)",
		],
		"description": "stoi"
	},
	"stoll":{
		"prefix":"stoll",
		"body":[
			"stoll(${1:str},0,${2:base});",
			"//str…変換したい文字列",
			"//base...変換する文字列の基数(2進数を変換したいなら2とする)",
		],
		"description": "stoll"
	},
	"to_string":{
		"prefix":"tos",
		"body":[
			"to_string(${1:n})",
		],
		"description": "to_string"
	},
	"for0n2":{
		"prefix":"for0n2",
		"body":[
			"for(int i=0;i<${1:n};i++){",
			"\tfor(int j=0;j<${2:m};j++){",
			"\t\t$3",
			"\t}",
			"}",
		],
		"description": "for0n2"
	},
	"for1n2":{
		"prefix":"for1n2",
		"body":[
			"for(int i=1;i<=${1:n};i++){",
			"\tfor(int j=1;j<=${2:m};j++){",
			"\t\t$3",
			"\t}",
			"}",
		],
		"description": "for1n2"
	},
	"for0n3":{
		"prefix":"for0n3",
		"body":[
			"for(int i=0;i<${1:n};i++){",
			"\tfor(int j=0;j<${2:m};j++){",
			"\t\tfor(int k=0;k<${3:l};k++){",
			"\t\t\t$4",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "for0n3"
	},
	"for1n3":{
		"prefix":"for1n3",
		"body":[
			"for(int i=1;i<=${1:n};i++){",
			"\tfor(int j=1;j<=${2:m};j++){",
			"\t\tfor(int k=1;k<=${3:l};k++){",
			"\t\t\t$4",
			"\t\t}",
			"\t}",
			"}",
		],
		"description": "for1n3"
	},
	"rsw":{
		"prefix":"rsw",
		"body":[
			"vector<int> rsw(${1:n}+1);",
			"for(int i=1;i<=${1:n};i++){",
			"\trsw[i]+=${2:a}[i]+rsw[i-1];",
			"}",
		],
		"description": "rsw"
	},
	"whilequery":{
		"prefix":"wq",
		"body":[
			"while(q--){",
			"\t$1",
			"}",
		],
		"description": "wq"
	},
	"calcrsw":{
		"prefix":"calcrsw",
		"body":[
			"${1:rsw}[${2:r}]-${1:rsw}[${3:l-1}]",
		],
		"description": "calcrsw"
	},
	"imos":{
		"prefix":"imos",
		"body":[
			"vector<int> imos(${1:d}+10);",
			"for(int i=0;i<${2:n};i++){",
			"\tint ${3:l},${4:r};",
			"\tcin>>${3:l}>>${4:r};",
			"\timos[${3:l}]++;",
			"\timos[${4:r}+1]--;",
			"}",
			"for(int i=1;i<=${1:d};i++){",
			"\timos[i]+=imos[i-1];",
			"}",
			"for(int i=1;i<=${1:d};i++){",
			"\tcout<<imos[i]<<'\\n';",
			"}",
		],
		"description": "imos"
	},
	"ci5":{
		"prefix":"ci5",
		"body":[
			"${1:int} ${2:a},${3:b},${4:c},${5:d},${6:e};",
			"cin>>${2:a}>>${3:b}>>${4:c}>>${5:d}>>${6:e};"
		],
		"description": "ci5"
	},
	"ci6":{
		"prefix":"ci6",
		"body":[
			"${1:int} ${2:a},${3:b},${4:c},${5:d},${6:e},${7:f};",
			"cin>>${2:a}>>${3:b}>>${4:c}>>${5:d}>>${6:e}>>${7:f};"
		],
		"description": "ci6"
	},
	"ci7":{
		"prefix":"ci7",
		"body":[
			"${1:int} ${2:a},${3:b},${4:c},${5:d},${6:e},${7:f},${8:g};",
			"cin>>${2:a}>>${3:b}>>${4:c}>>${5:d}>>${6:e}>>${7:f}>>${8:g};"
		],
		"description": "ci7"
	},
	"rsw2":{
		"prefix":"rsw2",
		"body":[
			"vector<vector<${0:int}>> rsw(${1:h}+1,vector<${0:int}>(${2:w}+1));",
			"//列方向への累積和",
			"for(int i=0;i<=${1:h};i++){",
			"\tfor(int j=1;j<=${2:w};j++){",
			"\t\trsw[i][j]+=${3:x}[i][j]+rsw[i][j-1];",
			"\t}",
			"}",
			"//行方向への累積和",
			"for(int j=0;j<=${2:w};j++){",
			"\tfor(int i=1;i<=${1:h};i++){",
			"\t\trsw[i][j]+=rsw[i-1][j];",
			"\t}",
			"}",
		],
		"description": "rsw2"
	},
	"calcrsw2":{
		"prefix":"calcrsw2",
		"body":[
			"rsw[${1:migisitaX}][${2:migisitaY}]+rsw[${3:hidariueX}-1][${4:hidariueY}-1]-rsw[${3:hidariueX}-1][${2:migisitaY}]-rsw[${1:migisitaX}][${4:hidariueY}-1]",
		],
		"description": "calcrsw2"
	},
	"imos2":{
		"prefix":"imos2",
		"body":[
			"vector<vector<int>> imos(${1:h}+2,vector<int>(${2:w}+2));",
			"for(int i=0;i<${3:n};i++){",
			"\tint ${4:hidariueX},${5:hidariueY},${6:migisitaX},${7:migisitaY};",
			"\tcin>>${4:hidariueX}>>${5:hidariueY}>>${6:migisitaX}>>${7:migisitaY};",
			"\timos[${4:hidariueX}][${5:hidariueY}]++;",
			"\timos[${4:hidariueX}][${7:migisitaY}+1]--;",
			"\timos[${6:migisitaX}+1][${5:hidariueY}]--;",
			"\timos[${6:migisitaX}+1][${7:migisitaY}+1]++;",
			"}",
			"//列方向に累積和",
			"for(int i=0;i<=${1:h};i++){",
			"\tfor(int j=1;j<=${2:w};j++){",
			"\t\timos[i][j]+=imos[i][j-1];",
			"\t}",
			"}",
			"//行方向に累積和",
			"for(int j=0;j<=${2:w};j++){",
			"\tfor(int i=1;i<=${1:h};i++){",
			"\t\timos[i][j]+=imos[i-1][j];",
			"\t}",
			"}",
			"for(int i=1;i<=${1:h};i++){",
			"\tfor(int j=1;j<=${2:w};j++){",
			"\t\tcout<<imos[i][j]<<((j!=${2:w})?' ':'\\n');",
			"\t}",
			"}",
		],
		"description": "imos2"
	},
	"rsmax":{
		"prefix":"rsmax",
		"body":[
			"vector<int> rsmax1(${1:n}+2),rsmax2(${1:n}+2);//1…左から,2…右から",
			"for(int i=1;i<=${1:n};i++){",
			"\trsmax1[i]=max(rsmax1[i-1],${2:a}[i]);",
			"}",
			"for(int i=${1:n};i>=1;i--){",
			"\trsmax2[i]=max(rsmax2[i+1],${2:a}[i]);",
			"}",
			"int ${3:d};",
			"cin>>${3:d};",
			"for(int i=0;i<${3:d};i++){",
			"\tint ${4:l},${5:r};",
			"\tcin>>${4:l}>>${5:r};",
			"\tcout<<max(rsmax1[${4:l}-1],rsmax2[${5:r}+1])<<'\\n';",
			"}",
		],
		"description": "rsmax"
	},
}